# 1.序列化与反序列化#
4/24/2022 9:33:38 PM 
## 概念 ##

   
	答：在java中对象进行网络传输或持久化时，需要把其转化为二进制流的形式。这种把对象转化为二进制流的过程，就成为序列化。
	反序列化与序列化过程相反。
	
	序列化的几种常见形式：

+	1. java 自身的序列化 实现serilizatiable接口，并生成唯一的SerilizationUID.
+	2. Hession 序列化
+	3. Java自身的序列化
	

# 2.Redis 缓存穿透 #
	
	答：
	大量请求的key根本不存在于缓存中，导致请求直接到数据库上，根本没有经过缓存这一层，根本没有经过缓存这一层。
	解决方案：
	1）缓存无效key，设置有效时间；
	2）布隆过滤器，把所有可能存在的请求的请求值存放再布隆过滤器中，不存在，直接返回错误信息给客户端，否则，去数据库中查询。
	


# 3.Redis 缓存雪崩 
	答：缓存在同一时间大面积失效，后面请求都会落到数据库下，造成数据库短时间内大量承受请求而崩掉。
	事前： 尽量保证整个Redis集群的高可用性，机器宕机尽快补上。选择合适的内存淘汰策略。
	事中： 本地ecache缓存+hystrix降流&降级，避免mysql崩掉。
	事后： 利用redis持久化机制，保存数据恢复缓存。
	


## 1 序列化与反序列化：
	
	* 内存中的数据对象只有转化为二进制流才可进行数据持久化和网络传输。将数据对象转换为二进制流的过程称为对象的序列化，又称为Serialization。
	* 序列化方式：
	* （1）Java 原生序列化
		实现Serializable接口，并建议设置SerialversionUIT字段值。
	* （2）Hessian序列化
		A.自描述序列化类型
		B.语言无关，支持脚本语言
		C.协议简单，比Java原生序列化高校
	* （3）JSON序列化
		JSON可读性好，方便调试。
		注意： 序列化要有安全防范意识，对传入数据内容进行校验或权限控制，及时更新漏洞。

## 2.缓存雪崩
	
	* 缓存同一时间大面积失效，所以，后面的请求都会落到数据库上，造成数据库短时间内接收到大量请求而崩掉。
	
	事前： 尽量保证整个Redis集群的高可用性，发现机器宕机，尽快补上，选择合适的内存淘汰策略。

	事中： 本地ecache缓存 + hystrix限流和降级，避免Mysql崩掉。

	事后： 利用Redis持久化机制，尽快恢复缓存。

## 3. 缓存穿透
	
	* 缓存穿透，就是大量请求的KEY 根本不存在于缓存中，导致缓存直接落到数据库上，根本没有经过缓存。

	解决办法：
	1. 缓存无效Key。
	2. 布隆过滤器。（把所有可能存在的请求值存放在布隆过滤器中，如不存在，直接返回错误给客户端，否则，去数据库中查询）
